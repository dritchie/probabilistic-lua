local util = require("probabilistic.util")
local mt = util.guardedTerraRequire("probabilistic.mathtracing")


-- Variables generated by ERPs
local RandomVariableRecord = {}

function RandomVariableRecord:new(name, erp, params, val, logprob, structural, conditioned, annotation)
	conditioned = (conditioned == nil) and false or conditioned
	local newobj = { name = name, erp = erp, params = params, val = val, logprob = logprob,
			   active = true, structural = structural, conditioned = conditioned,
			   annotation = annotation }
	setmetatable(newobj, self)
	self.__index = self
	return newobj
end

function RandomVariableRecord:copy()
	return RandomVariableRecord:new(self.name, self.erp, self.params, self.val, self.logprob,
									self.structural, self.conditioned, self.annotation)
end

function RandomVariableRecord:getProp(propname)
	return self[propname]
end

function RandomVariableRecord:setProp(propname, val)
	self[propname] = val
end


-- Execution trace generated by a probabilistic program.
-- Tracks the random choices made and accumulates probabilities
local RandomExecutionTrace = {}

function RandomExecutionTrace:new(computation, doRejectionInit)
	doRejectionInit = (doRejectionInit == nil) and true or doRejectionInit
	local newobj = {
		computation = computation,
		vars = {},
		varlist = {},
		currVarIndex = 1,
		logprob = 0.0,
		newlogprob = 0.0,
		oldlogprob = 0.0,
		rootframe = nil,
		loopcounters = {},
		conditionsSatisfied = false,
		returnValue = nil,
		evaluatingFactorThunks = true
	}
	setmetatable(newobj, self)
	self.__index = self

	if doRejectionInit then
		while not newobj.conditionsSatisfied do
			util.cleartable(newobj.vars)
			newobj:traceUpdate()
		end
	end

	return newobj
end

function RandomExecutionTrace:deepcopy()
	local newdb = RandomExecutionTrace:new(self.computation, false)
	newdb.logprob = self.logprob
	newdb.oldlogprob = self.oldlogprob
	newdb.newlogprob = self.newlogprob
	newdb.conditionsSatisfied = self.conditionsSatisfied
	newdb.returnValue = self.returnValue
	newdb.evaluatingFactorThunks = self.evaluatingFactorThunks

	for i,v in ipairs(self.varlist) do
		local newv = v:copy()
		newdb.varlist[i] = newv
		newdb.vars[v.name] = newv
	end

	return newdb
end

function RandomExecutionTrace:freeVarNames(structural, nonstructural)
	structural = (structural == nil) and true or structural
	nonstructural = (nonstructural == nil) and true or nonstructural
	return util.map(
		function(rec) return rec.name end,
		util.listfilter(
			function(rec)
				return not rec.conditioned and
						((structural and rec.structural) or
						(nonstructural and not rec.structural))
			end,
			self.varlist))
end

-- Names of variables that this trace has that the other does not
function RandomExecutionTrace:varDiff(other)
	local tbl = {}
	for k,v in pairs(self.vars) do
		if not other.vars[k] then
			table.insert(tbl, k)
		end
	end
	return tbl
end

-- Difference in log probability between this trace and the other
-- due to variables that this one has that the other does not
function RandomExecutionTrace:lpDiff(other)
	return util.sumtable(
		util.map(
			function(name) return self.vars[name].logprob end,
			self:varDiff(other)))
end

-- A list of objects (typically strings) which uniquely identify
-- the structure of this execution trace
-- (These are typically used as keys in a hash table)
-- Most traces only have one such unique identifier, but some
-- (e.g. LARJ annealing traces) may have two or more equivalent
-- identifiers. Thus, this method returns a list.
function RandomExecutionTrace:structuralSignatures()
	local sig = ""
	-- Loop through the variables in order of creation
	-- Add a [name]<val> chunk to the signature for every structural variable
	for i,v in ipairs(self.varlist) do
		if v.structural then
			sig = string.format("%s,[%s]<%g>", sig, v.name, v.val)
		end
	end
	return {sig}
end

-- Toggle factor evaluation on/off
-- If off, then factor thunks will not be evaluated
-- When factors are very expensive, this saves a lot of time
-- If we only need to run the program forward to regenerate some result.
function RandomExecutionTrace:toggleFactorEval(switch)
	self.evaluatingFactorThunks = switch
end

-- The singleton trace object
local trace = nil

-- Run computation and update this trace accordingly
function RandomExecutionTrace:traceUpdate(structureIsFixed)
	local origtrace = trace
	trace = self

	self.logprob = 0.0
	self.newlogprob = 0.0
	util.cleartable(self.loopcounters)
	self.conditionsSatisfied = true
	self.currVarIndex = 1

	-- If updating this trace can change the variable structure, then we
	-- clear out the flat list of variables beforehand
	if not structureIsFixed then
		util.cleartable(self.varlist)
	end

	-- Mark all variables as inactive; only those reached
	-- by the computation will become 'active'
	for name,rec in pairs(self.vars) do
		rec.active = false
	end

	-- Mark that this is the 'root' frame of the current execution trace
	self.rootframe = debug.getinfo(1, 'p').fnprotoid

	-- Run the computation, which will create/lookup random variables
	self.returnValue = self.computation()

	-- Clean up
	self.rootframe = nil
	util.cleartable(self.loopcounters)

	-- Clear out any random values that are no longer reachable
	self.oldlogprob = 0.0
	for name,rec in pairs(self.vars) do
		if not rec.active then
			self.oldlogprob = self.oldlogprob + rec.logprob
			self.vars[name] = nil
		end
	end

	-- Reset the singleton trace
	trace = origtrace
end

-- Recompute all ERP prior logprobs, and then the full logprob
-- using a traceUpdate
function RandomExecutionTrace:flushLogProbs()
	for i,v in pairs(self.varlist) do
		v.logprob = v.erp:logprob(v.val, v.params)
	end
	self:traceUpdate(true)
end


-- Return the current structural name, as determined by the interpreter stack
function RandomExecutionTrace:currentName(numFrameSkip)
	
	-- Get list of frames from the root frame to the current frame
	local i = 2 + numFrameSkip
	local flst = {}
	local f = nil
	repeat
		f = debug.getinfo(i, 'p')
		table.insert(flst, 1, f)
		i = i + 1
	until not f or (self.rootframe and f.fnprotoid == self.rootframe)
	-- logfile:write(iteration .. "," .. table.getn(flst) .. "\n")
	-- iteration = iteration + 1

	-- Build up name string, checking loop counters along the way
	local name = ""
	for i=1,table.getn(flst)-1 do
		f = flst[i]
		name = string.format("%s%d:%d", name, f.fnprotoid, f.bytecodepos)
		local loopnum = self.loopcounters[name] or 0
		name = string.format("%s:%d|", name, loopnum)
	end
	-- For the last (topmost frame), also increment the loop counter
	f = flst[table.getn(flst)]
	name = string.format("%s%d:%d", name, f.fnprotoid, f.bytecodepos)
	local loopnum = self.loopcounters[name] or 0
	self.loopcounters[name] = loopnum + 1
	name = string.format("%s:%d|", name, loopnum)

	return name
end

-- Looks up the value of a random variable.
-- Creates the variable if it does not already exist
function RandomExecutionTrace:lookup(erp, params, numFrameSkip, isStructural, conditionedValue, annotation, recomputeLP)
	local record = nil
	local name = nil
	-- Try to find the variable (first check the flat list, then do slower name lookup)
	local varIsInFlatList = self.currVarIndex <= table.getn(self.varlist)
	if varIsInFlatList then
		record = self.varlist[self.currVarIndex]
	else
		name = self:currentName(numFrameSkip+1)
		record = self.vars[name]
		if not record or record.erp ~= erp or isStructural ~= record.structural then
			record = nil
		end
	end
	-- If we didn't find the variable, create a new one
	if not record then
		local val = conditionedValue or erp:sample(params)
		local ll = erp:logprob(val, params)
		self.newlogprob  = self.newlogprob + ll
		record = RandomVariableRecord:new(name, erp, params, val, ll, isStructural, conditionedValue ~= nil, annotation)
		self.vars[name] = record
	-- Otherwise, reuse the variable we found, but check if its parameters/conditioning
	-- status/etc. have changed
	else
		record.annotation = annotation
		record.conditioned = (conditionedValue ~= nil)
		-- If we're JITing this computation, then we have different logic to follow
		if mt and mt.isOn() and not isStructural then
			mt.traceNonstructuralVariable(record)
		-- Otherwise, proceed normally
		else
			local hasChanges = recomputeLP
			-- If params have changed, we need to recompute log prob
			if not util.arrayequals(record.params, params) then
				record.params = params
				hasChanges = true
			end
			-- If the conditioned value has changed, we also need to recompute log prob
			if conditionedValue and conditionedValue ~= record.val then
				record.val = conditionedValue
				record.conditioned = true
				hasChanges = true
			end
			if hasChanges then
				record.logprob = erp:logprob(record.val, params)
			end
		end
	end

	-- Final bookkeeping
	if not varIsInFlatList then
		table.insert(self.varlist, record)
	end
	self.currVarIndex = self.currVarIndex + 1
	self.logprob = self.logprob + record.logprob
	record.active = true
	return record.val
end


-- Get a record object which stores information about the random
-- variable named 'name'
function RandomExecutionTrace:getRecord(name)
	return self.vars[name]
end

-- Add a new factor into the log-likelihood of this trace
function RandomExecutionTrace:addFactor(num)
	self.logprob = self.logprob + num
end

-- Evaluate a thunk and add the result into the log-likelihood of this trace
function RandomExecutionTrace:addFactorThunk(thunk)
	if self.evaluatingFactorThunks then
		self.logprob = self.logprob + thunk()
	end
end

-- Condition the trace on the value of a boolean expression
function RandomExecutionTrace:conditionOn(boolexpr)
	self.conditionsSatisfied = self.conditionsSatisfied and boolexpr
end



-- Exported functions for interacting with the singleton trace

local function lookupVariableValue(erp, params, isStructural, numFrameSkip, conditionedValue, annotation, recomputeLP)
	if not trace then
		return conditionedValue or erp:sample(params)
	else
		-- We don't do numFrameSkip + 1 because this is a tail call
		return trace:lookup(erp, params, numFrameSkip, isStructural, conditionedValue, annotation, recomputeLP)
	end
end

local function newTrace(computation)
	return RandomExecutionTrace:new(computation)
end

local function factor(num)
	if trace then
		trace:addFactor(num)
	end
end

local function factorThunk(thunk)
	if trace then
		trace:addFactorThunk(thunk)
	end
end

local function condition(boolexpr)
	if trace then
		trace:conditionOn(boolexpr)
	end
end

return
{
	RandomExecutionTrace = RandomExecutionTrace,
	lookupVariableValue = lookupVariableValue,
	newTrace = newTrace,
	factor = factor,
	condition = condition
}